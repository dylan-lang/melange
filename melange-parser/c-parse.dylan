module: c-parse
author:  Robert Stockton (rgs@cs.cmu.edu)
copyright: see below
	   This code was produced by the Gwydion Project at Carnegie Mellon
	   University.  If you are interested in using this code, contact
	   "Scott.Fahlman@cs.cmu.edu" (Internet).

//======================================================================
//
// Copyright (c) 1994  Carnegie Mellon University
// Copyright (c) 1998, 1999, 2000  Gwydion Dylan Maintainers
// All rights reserved.
//
//======================================================================

//======================================================================
// Module c-parse handles parsing of native C header files.  Theoretically, we
// could have arbitrary C code in these files.  However, in practice we only
// need to be able to parse about half of the C language.
//
// The actual "source" for the c parser is contained in "c-parse.input", which
// is an input file for parsergen.
// "C-parse.dylan" is the pure Dylan output of this generator, and should
// *not* be considered human readable code.
//
// The "parse-tree" is a very ad-hoc structure, because it is intended to be
// quite ephemeral.  The final goal is to add an ordered sequence of
// <declaration>s to the <parse-state> which both controls the parsing process
// and returns the results of the parse.  This approach allows us to do a
// single pass parse of the data, and also support the feedback required to
// handle C's "type names", which are context sensitive.
//
// The token stream provided by the tokenizer may actually correspond to
// several different "included" files.  We can detect transitions into and out
// of recursively included files by watching for <begin-include-token> and
// <end-include-token>.  We make the simplifying assumption that declarations
// will not be split across include files.  This assumption should be
// justifiable on the basis that any exception would be unbearably ugly.
//
// The raw parse engine has been fitted with a number of different front ends
// to allow several different types of data to be parsed.  The following
// functions are exported:
//   parse(filename, #key defines, undefines) => result :: <parse-file-state>
//     This function processes an entire include file, leaving a series of
//     declarations in the returned parse state.
//   parse-type(alien-name :: <string>, old-state :: <parse-file-state>)
//   => result :: <declaration>
//     This function parses the contents of the given string and tries to
//     interpret it as the name of an object or type declared in "old-state".
//     Parse-type will signal an error if no such declaration is found.
//   parse-macro(cpp-name :: <string>, old-state :: <parse-file-state>)
//   => result :: constant-value or <declaration>
//     This function tries to evaluate a preprocessor constant in hopes that
//     it will either evaluate to a type or object name or to a constant
//     compile time value.  It returns the matched declaration or value, or it
//     signals an error. 
//   cpp-parse(tokenizer :: <tokenizer>) => result :: <integer>
//     This function evaluates a line of CPP input according to a limited set
//     of C operators and an odd set of evaluation rules which make undefined
//     identifiers into integers.  (Note that this function is used by the
//     tokenizer, but also recursively uses the tokenizer by specifying a few
//     magic keywords to avoid infinite recursion.)  This function consumes
//     one line's worth of tokens from the tokenizer and then leaves it in a
//     consistent state for further processing by a different parser.
//
// The input file is messier than it might be, because we have retained
// productions corresponding to the entire C language -- simply commenting out
// the ones which are not needed for header files.  This should simplify
// future expansion.
//======================================================================

//----------------------------------------------------------------------
// Simple parser support 
//----------------------------------------------------------------------

// *HACK*: We temporarily use a global variable to figure out whether a given
// declaration is an object declaration or a typedef declaration.  This
// appears to be simpler than trying to propagate detailed information
// upwards.
//
define variable *typedef-flag* = #f;

// This function checks to see whether the given object can be interpreted as
// an integer.  If so, it returns the integer value.  Otherwise, it raises an
// error.  This function is used to evaluate compile time constants.
//
define generic int-value (value :: <object>, state :: <parse-state>);

define method int-value (value :: <integer>, state :: <parse-state>)
  value;
end method;

define method int-value (token :: <integer-token>, state :: <parse-state>)
  token.value;
end method;

define method int-value (value :: <character>, state :: <parse-state>)
  as(<integer>, value);
end method;

define method int-value (token :: <character-token>, state :: <parse-state>)
  as(<integer>, token.value);
end method;

define method int-value (value :: <object>, state :: <parse-state>)
  error(value, 
	"Value in constant expression must be an integer, but is %=\n.",
	value);
end method;

// This method will only be called if we are evaluating an expression in a CPP
// line.  It is not called for arbitrary identifiers.
//
define method int-value
    (value :: <identifier-token>, state :: <parse-value-state>)
  let expansion = element(value.generator.cpp-table,
                          value.string-value, default: #f);
  case
    expansion == #f => 
      // The C preprocessor blithely accepts undefined identifiers as "0"
      0;
    empty?(expansion) =>
      1;
    expansion.size > 1 =>
      format(*standard-error*, "Parsing odd macro: %=\n", value.string-value);
      int-value(parse-macro(value.string-value, state), state);
    otherwise =>
      int-value(head(expansion), state);
  end case;
end method;

// Evaluate identifiers in the case where we are *not* evaluating an
// expression in a CPP line.
//
define method int-value
    (value :: <identifier-token>, state :: <parse-state>)
  let object-decl = element(state.objects, value.string-value, default: #f);
  if (instance?(object-decl, <enum-slot-declaration>))
    object-decl.constant-value;
  else
    parse-error(value, 
	"Value in constant expression must be an integer, but isn't.");
  end if;
end method int-value;

define constant <source-location> = false-or(<parse-state>);


//----------------------------------------------------------------------
// The actual productions.  The format is
//  production (sub-production-or-<token> .....)
//    Arbitrary dylan code -- variables %1 - %n correspond to the
//    sub-productions, and @0 is a <parse-state> which is passed into each
//    action routine for record-keeping purposes.
//  %
//----------------------------------------------------------------------

define constant $action-bits = 2;
define constant $action-mask = ash(1, $action-bits) - 1;

define constant $error-action = 0;
define constant $accept-action = 1;
define constant $reduce-action = 2;
define constant $shift-action = 3;

define constant $action-table
  = #[#[7, 0, 11, 15, 0, 179, 0, 0, 0, 0, 51, 39, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 27, 931, 19, 0, 0, 0, 55, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1003, 1023, 1051, 0],
      #[6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[634, 0, 634, 634, 0, 634, 0, 0, 0, 0, 634, 634, 634, 634, 634, 634, 634, 634, 634, 634, 634, 634, 634, 634, 634, 0, 0, 0, 634, 634, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[638, 0, 638, 638, 0, 638, 0, 0, 0, 0, 638, 638, 638, 638, 638, 638, 638, 638, 638, 638, 638, 638, 638, 638, 638, 0, 0, 0, 638, 638, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 290, 0, 0, 0, 0, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 23, 290, 0, 0, 0, 0, 290, 290, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 294, 0, 0, 0, 0, 294, 294, 294, 294, 294, 294, 294, 294, 294, 294, 294, 294, 0, 294, 0, 0, 0, 0, 294, 294, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 286, 0, 0, 0, 0, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 0, 286, 31, 0, 0, 0, 286, 286, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 298, 0, 0, 0, 0, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 0, 298, 0, 0, 0, 0, 298, 298, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 179, 0, 0, 0, 0, 51, 39, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 0, 43, 0, 0, 0, 0, 55, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 358, 0, 0, 0, 0, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 0, 358, 0, 0, 0, 0, 358, 358, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 362, 0, 0, 0, 0, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 0, 362, 0, 0, 0, 0, 362, 362, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 179, 0, 0, 0, 0, 51, 39, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 0, 43, 0, 0, 0, 0, 55, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 398, 398, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 398, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 402, 402, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 402, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 823, 823, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 63, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 179, 0, 0, 0, 0, 51, 0, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 0, 0, 0, 0, 0, 0, 55, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[374, 0, 0, 0, 374, 374, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 374, 374, 0, 374, 374, 374, 0, 0, 374, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 374, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 743, 743, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 0, 0, 0, 0, 0],
      #[0, 0, 83, 87, 642, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 0],
      #[454, 0, 0, 0, 454, 454, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 454, 454, 0, 454, 454, 454, 0, 0, 454, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 454, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 646, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 646, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 646, 0, 0, 0, 0],
      #[0, 0, 0, 0, 650, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 650, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 650, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[658, 0, 658, 658, 658, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 658, 658, 0, 658, 658, 658, 658, 658, 658, 658, 658, 658, 658, 658, 658, 0, 0, 658, 658, 658, 658, 658, 658, 658, 658, 658, 658, 0, 658, 658, 658, 658, 658, 0, 0, 0, 0],
      #[0, 0, 474, 474, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 474, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 103, 0, 474, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[50, 0, 50, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 50, 0, 50, 50, 0, 50, 50, 50, 50, 50, 50, 50, 50, 50, 0, 0, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 0, 50, 50, 0, 0, 50, 0, 0, 0, 0],
      #[54, 0, 54, 54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 54, 54, 0, 54, 54, 0, 54, 54, 54, 54, 54, 54, 54, 54, 54, 0, 0, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 0, 54, 54, 0, 0, 54, 0, 0, 0, 0],
      #[46, 0, 46, 46, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 46, 46, 0, 46, 46, 0, 46, 46, 46, 46, 46, 46, 46, 46, 46, 0, 0, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 0, 46, 46, 0, 0, 46, 0, 0, 0, 0],
      #[62, 0, 62, 62, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 62, 0, 62, 62, 0, 62, 62, 62, 62, 62, 62, 62, 62, 62, 0, 0, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 0, 62, 62, 0, 0, 62, 0, 0, 0, 0],
      #[66, 0, 66, 66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66, 66, 0, 66, 66, 0, 66, 66, 66, 66, 66, 66, 66, 66, 66, 0, 0, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 0, 66, 66, 0, 0, 66, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 131, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 139, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[74, 0, 74, 74, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 74, 74, 0, 74, 74, 0, 74, 74, 74, 74, 74, 74, 74, 74, 74, 0, 0, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 0, 74, 74, 0, 0, 74, 0, 0, 0, 0],
      #[86, 0, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 86, 0, 147, 86, 0, 86, 86, 86, 86, 86, 86, 86, 86, 86, 0, 0, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 0, 86, 86, 0, 0, 86, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[0, 0, 0, 0, 98, 0, 98, 98, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 98, 0, 0, 0, 0, 0, 0, 98, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 98, 98, 98, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 98],
      #[0, 0, 0, 0, 102, 0, 102, 102, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 102, 0, 0, 0, 0, 0, 0, 102, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 102, 102, 102, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 102],
      #[0, 0, 0, 0, 106, 0, 106, 106, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 106, 0, 0, 0, 0, 0, 0, 106, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 106, 106, 106, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 106],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 171, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 179, 0, 0, 0, 0, 51, 0, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 0, 0, 0, 0, 0, 0, 55, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[378, 0, 0, 0, 378, 378, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 378, 378, 0, 378, 378, 378, 0, 0, 378, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 378, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[382, 0, 0, 0, 382, 382, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 382, 382, 0, 382, 382, 382, 0, 0, 382, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 382, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[530, 0, 0, 0, 530, 530, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 530, 530, 0, 530, 530, 530, 0, 0, 530, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 530, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[366, 0, 0, 0, 366, 366, 0, 0, 0, 0, 0, 0, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 366, 366, 0, 366, 366, 366, 0, 0, 366, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 366, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[370, 0, 0, 0, 370, 370, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 370, 370, 0, 370, 370, 370, 0, 0, 370, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 370, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[534, 0, 0, 0, 534, 534, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 534, 534, 0, 534, 534, 534, 0, 0, 534, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 534, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[578, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 578, 0, 463, 578, 203, 0, 0, 611, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 207, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[602, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 602, 0, 602, 602, 602, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[110, 0, 110, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 110, 110, 0, 0, 110, 0, 110, 110, 110, 110, 110, 110, 110, 110, 110, 0, 0, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 0, 110, 110, 0, 0, 110, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 179, 107, 111, 0, 0, 51, 0, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 0, 0, 0, 0, 0, 0, 55, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[118, 0, 118, 118, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 118, 118, 0, 0, 118, 0, 118, 118, 118, 118, 118, 118, 118, 118, 118, 0, 0, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 0, 118, 118, 0, 0, 118, 0, 0, 0, 0],
      #[134, 0, 134, 134, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 134, 134, 0, 0, 134, 0, 134, 134, 227, 134, 134, 243, 235, 134, 134, 0, 0, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 0, 134, 134, 0, 0, 134, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[122, 0, 122, 122, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 122, 122, 0, 0, 122, 0, 122, 122, 122, 122, 122, 122, 122, 122, 122, 0, 0, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 0, 122, 122, 0, 0, 122, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[126, 0, 126, 126, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 126, 126, 0, 0, 126, 0, 126, 126, 126, 126, 126, 126, 126, 126, 126, 0, 0, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 0, 126, 126, 0, 0, 126, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[130, 0, 130, 130, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 130, 130, 0, 0, 130, 0, 130, 130, 130, 130, 130, 130, 130, 130, 130, 0, 0, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 0, 130, 130, 0, 0, 130, 0, 0, 0, 0],
      #[146, 0, 146, 146, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 146, 146, 0, 0, 146, 0, 146, 146, 0, 146, 146, 0, 0, 255, 263, 0, 0, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 0, 146, 146, 0, 0, 146, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[138, 0, 138, 138, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 138, 0, 0, 138, 0, 138, 138, 227, 138, 138, 243, 235, 138, 138, 0, 0, 138, 138, 138, 138, 138, 138, 138, 138, 138, 138, 0, 138, 138, 0, 0, 138, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[142, 0, 142, 142, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 142, 142, 0, 0, 142, 0, 142, 142, 227, 142, 142, 243, 235, 142, 142, 0, 0, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 0, 142, 142, 0, 0, 142, 0, 0, 0, 0],
      #[158, 0, 158, 158, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 158, 158, 0, 0, 158, 0, 158, 158, 0, 158, 158, 0, 0, 0, 0, 0, 0, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 0, 275, 283, 0, 0, 158, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[150, 0, 150, 150, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 150, 150, 0, 0, 150, 0, 150, 150, 0, 150, 150, 0, 0, 255, 263, 0, 0, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 0, 150, 150, 0, 0, 150, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[154, 0, 154, 154, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 154, 154, 0, 0, 154, 0, 154, 154, 0, 154, 154, 0, 0, 255, 263, 0, 0, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 0, 154, 154, 0, 0, 154, 0, 0, 0, 0],
      #[178, 0, 178, 178, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 178, 178, 0, 0, 178, 0, 178, 178, 0, 178, 178, 0, 0, 0, 0, 0, 0, 295, 303, 178, 178, 178, 311, 319, 178, 178, 178, 0, 0, 0, 0, 0, 178, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[162, 0, 162, 162, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 162, 162, 0, 0, 162, 0, 162, 162, 0, 162, 162, 0, 0, 0, 0, 0, 0, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 0, 275, 283, 0, 0, 162, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[166, 0, 166, 166, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 166, 166, 0, 0, 166, 0, 166, 166, 0, 166, 166, 0, 0, 0, 0, 0, 0, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 0, 275, 283, 0, 0, 166, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[170, 0, 170, 170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 170, 170, 0, 0, 170, 0, 170, 170, 0, 170, 170, 0, 0, 0, 0, 0, 0, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 0, 275, 283, 0, 0, 170, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[174, 0, 174, 174, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 174, 174, 0, 0, 174, 0, 174, 174, 0, 174, 174, 0, 0, 0, 0, 0, 0, 174, 174, 174, 174, 174, 174, 174, 174, 174, 174, 0, 275, 283, 0, 0, 174, 0, 0, 0, 0],
      #[190, 0, 190, 190, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 190, 190, 0, 0, 190, 0, 190, 190, 0, 190, 190, 0, 0, 0, 0, 0, 0, 0, 0, 190, 190, 331, 0, 0, 339, 190, 190, 0, 0, 0, 0, 0, 190, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[182, 0, 182, 182, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 182, 182, 0, 0, 182, 0, 182, 182, 0, 182, 182, 0, 0, 0, 0, 0, 0, 295, 303, 182, 182, 182, 311, 319, 182, 182, 182, 0, 0, 0, 0, 0, 182, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[186, 0, 186, 186, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 186, 186, 0, 0, 186, 0, 186, 186, 0, 186, 186, 0, 0, 0, 0, 0, 0, 295, 303, 186, 186, 186, 311, 319, 186, 186, 186, 0, 0, 0, 0, 0, 186, 0, 0, 0, 0],
      #[198, 0, 198, 198, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 198, 198, 0, 0, 198, 0, 198, 351, 0, 198, 198, 0, 0, 0, 0, 0, 0, 0, 0, 198, 198, 0, 0, 0, 0, 198, 198, 0, 0, 0, 0, 0, 198, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[194, 0, 194, 194, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 194, 194, 0, 0, 194, 0, 194, 194, 0, 194, 194, 0, 0, 0, 0, 0, 0, 0, 0, 194, 194, 331, 0, 0, 339, 194, 194, 0, 0, 0, 0, 0, 194, 0, 0, 0, 0],
      #[206, 0, 206, 206, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 206, 206, 0, 0, 206, 0, 206, 0, 0, 363, 206, 0, 0, 0, 0, 0, 0, 0, 0, 206, 206, 0, 0, 0, 0, 206, 206, 0, 0, 0, 0, 0, 206, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[202, 0, 202, 202, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 202, 202, 0, 0, 202, 0, 202, 351, 0, 202, 202, 0, 0, 0, 0, 0, 0, 0, 0, 202, 202, 0, 0, 0, 0, 202, 202, 0, 0, 0, 0, 0, 202, 0, 0, 0, 0],
      #[214, 0, 214, 214, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 214, 214, 0, 0, 214, 0, 214, 0, 0, 0, 375, 0, 0, 0, 0, 0, 0, 0, 0, 214, 214, 0, 0, 0, 0, 214, 214, 0, 0, 0, 0, 0, 214, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[210, 0, 210, 210, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 210, 210, 0, 0, 210, 0, 210, 0, 0, 363, 210, 0, 0, 0, 0, 0, 0, 0, 0, 210, 210, 0, 0, 0, 0, 210, 210, 0, 0, 0, 0, 0, 210, 0, 0, 0, 0],
      #[222, 0, 222, 222, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 222, 222, 0, 0, 222, 0, 222, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 222, 222, 0, 0, 0, 0, 387, 222, 0, 0, 0, 0, 0, 222, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[218, 0, 218, 218, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 218, 218, 0, 0, 218, 0, 218, 0, 0, 0, 375, 0, 0, 0, 0, 0, 0, 0, 0, 218, 218, 0, 0, 0, 0, 218, 218, 0, 0, 0, 0, 0, 218, 0, 0, 0, 0],
      #[230, 0, 230, 230, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230, 230, 0, 0, 230, 0, 230, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 407, 0, 0, 0, 0, 0, 0, 399, 0, 0, 0, 0, 0, 230, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[226, 0, 226, 226, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 226, 226, 0, 0, 226, 0, 226, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 226, 226, 0, 0, 0, 0, 387, 226, 0, 0, 0, 0, 0, 226, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 415, 0, 0, 0, 0, 0, 399, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[234, 0, 234, 234, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 234, 234, 0, 0, 234, 0, 234, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 234, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 238, 0, 0, 238, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 242, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 435, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[58, 0, 58, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 58, 58, 0, 58, 58, 0, 58, 58, 58, 58, 58, 58, 58, 58, 58, 0, 0, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 0, 58, 58, 0, 0, 58, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 443, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[114, 0, 114, 114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 114, 114, 0, 0, 114, 0, 114, 114, 114, 114, 114, 114, 114, 114, 114, 0, 0, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 0, 114, 114, 0, 0, 114, 0, 0, 0, 0],
      #[246, 0, 246, 246, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 246, 246, 0, 0, 0, 0, 246, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 246, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 459, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[606, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 606, 0, 606, 606, 606, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 179, 0, 0, 0, 0, 51, 0, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 0, 0, 0, 0, 0, 0, 55, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 463, 639, 203, 0, 0, 611, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[590, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 590, 0, 487, 590, 471, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 475, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[610, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 610, 0, 610, 610, 610, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 483, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[614, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 614, 0, 614, 614, 614, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 179, 0, 0, 0, 0, 51, 0, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 0, 0, 0, 0, 0, 0, 55, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 491, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[626, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 626, 0, 626, 626, 626, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[578, 0, 0, 0, 95, 503, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 578, 0, 599, 578, 203, 0, 0, 611, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 490, 490, 0, 490, 490, 490, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 490, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 490, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 494, 494, 0, 494, 494, 494, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 494, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 494, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 482, 482, 0, 527, 482, 511, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 482, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 482, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 515, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 502, 502, 0, 502, 502, 502, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 502, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 502, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 523, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 506, 506, 0, 506, 506, 506, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 506, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 506, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 179, 0, 0, 0, 0, 51, 0, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 0, 0, 0, 0, 0, 0, 55, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 531, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 510, 510, 0, 510, 510, 510, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 510, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 510, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 574, 0, 0, 574, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 562, 0, 0, 562, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 547, 0, 0, 554, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 179, 0, 0, 0, 0, 51, 0, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 0, 0, 0, 0, 0, 0, 55, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 555, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 566, 0, 0, 566, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 558, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 563, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 514, 514, 0, 514, 514, 514, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 514, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 514, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 546, 0, 0, 546, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 575, 0, 0, 538, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 583, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 550, 0, 0, 550, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 542, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 591, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 518, 518, 0, 518, 518, 518, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 518, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 518, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 570, 0, 0, 570, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 643, 0, 0, 0, 0, 51, 0, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 0, 0, 0, 0, 0, 0, 55, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 599, 639, 203, 0, 0, 611, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 607, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 498, 498, 0, 498, 498, 498, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 498, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 498, 0, 0, 0, 0, 0],
      #[522, 0, 0, 0, 522, 522, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 522, 0, 522, 522, 522, 0, 0, 611, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[526, 0, 0, 0, 526, 526, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 526, 0, 526, 526, 526, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[586, 0, 0, 0, 95, 503, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 586, 0, 599, 586, 203, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 486, 486, 0, 527, 486, 511, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 486, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 486, 0, 0, 0, 0, 0],
      #[594, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 594, 0, 487, 594, 471, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 635, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[598, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 598, 0, 598, 598, 598, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[618, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 618, 0, 618, 618, 618, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[382, 0, 0, 0, 382, 382, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 382, 382, 0, 382, 382, 382, 0, 0, 382, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 382, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 494, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 651, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[622, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 622, 0, 622, 622, 622, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[582, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 582, 0, 0, 582, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 663, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[630, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 630, 0, 630, 630, 630, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[586, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 586, 0, 463, 586, 203, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 675, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[94, 0, 94, 94, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 94, 94, 0, 0, 94, 0, 94, 94, 94, 94, 94, 94, 94, 94, 94, 0, 0, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 0, 94, 94, 0, 0, 94, 0, 0, 0, 0],
      #[90, 0, 90, 90, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90, 90, 0, 0, 90, 0, 90, 90, 90, 90, 90, 90, 90, 90, 90, 0, 0, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 0, 90, 90, 0, 0, 90, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 0, 0, 78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 691, 0, 0, 699, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 82, 0, 0, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[70, 0, 70, 70, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 70, 70, 0, 70, 70, 0, 70, 70, 70, 70, 70, 70, 70, 70, 70, 0, 0, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 0, 70, 70, 0, 0, 70, 0, 0, 0, 0],
      #[0, 0, 478, 478, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 478, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 478, 0, 0, 0, 0],
      #[0, 0, 466, 466, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 466, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 466, 0, 0, 0, 0],
      #[0, 0, 83, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 642, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 642, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 723, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 719, 0, 0, 0, 0],
      #[458, 0, 0, 0, 458, 458, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 458, 458, 0, 458, 458, 458, 0, 0, 458, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 458, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 83, 87, 642, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 642, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 735, 0, 0, 0, 0],
      #[0, 0, 470, 470, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 470, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 470, 0, 0, 0, 0],
      #[462, 0, 0, 0, 462, 462, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 462, 462, 0, 462, 462, 462, 0, 0, 462, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 462, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[442, 0, 0, 0, 442, 442, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 442, 442, 0, 442, 442, 442, 0, 0, 442, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 442, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[450, 0, 0, 0, 450, 450, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 450, 450, 0, 450, 450, 450, 0, 0, 450, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 450, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 0, 0, 0, 0, 0],
      #[446, 0, 0, 0, 446, 446, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 446, 446, 0, 446, 446, 446, 0, 0, 446, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 446, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 503, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 803, 0, 0, 763, 0, 0, 0, 0, 611, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 755, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 434, 434, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 503, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 763, 0, 0, 0, 0, 611, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 503, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 763, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 430, 430, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 775, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 438, 438, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 422, 422, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 799, 791, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 503, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 763, 0, 0, 0, 0, 611, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 755, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 426, 426, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 414, 0, 0, 0, 0, 414, 0, 414, 414, 414, 414, 414, 414, 414, 414, 414, 414, 0, 0, 0, 0, 0, 0, 414, 414, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 414, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 418, 0, 0, 0, 0, 418, 0, 418, 418, 418, 418, 418, 418, 418, 418, 418, 418, 0, 0, 0, 0, 0, 0, 418, 418, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 418, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 406, 0, 0, 0, 0, 406, 0, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 0, 0, 0, 0, 0, 0, 406, 406, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 406, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 179, 0, 0, 0, 0, 51, 0, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 0, 0, 0, 0, 0, 0, 55, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 819, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 410, 0, 0, 0, 0, 410, 0, 410, 410, 410, 410, 410, 410, 410, 410, 410, 410, 0, 0, 0, 0, 0, 0, 410, 410, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 410, 0, 0, 0, 0],
      #[390, 0, 0, 0, 390, 390, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 390, 390, 0, 390, 390, 390, 0, 0, 390, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 390, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[394, 0, 0, 0, 394, 394, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 394, 394, 0, 394, 394, 394, 0, 0, 394, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 394, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 827, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 179, 0, 0, 0, 0, 51, 0, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 0, 0, 0, 0, 0, 0, 55, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 179, 0, 0, 0, 0, 51, 0, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 0, 0, 0, 0, 0, 0, 55, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 835, 0, 0, 0, 0],
      #[386, 0, 0, 0, 386, 386, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 386, 386, 0, 386, 386, 386, 0, 0, 386, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 386, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 318, 318, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 318, 0, 0, 318, 0, 0, 0, 0, 318, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 322, 322, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 322, 0, 0, 322, 0, 0, 0, 0, 322, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 314, 314, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 314, 0, 0, 314, 0, 0, 0, 0, 314, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 859, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 763, 0, 0, 0, 0, 611, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 334, 334, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 334, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 494, 494, 0, 494, 494, 494, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 494, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 494, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 867, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 763, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 494, 494, 0, 494, 494, 494, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 494, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 494, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 342, 342, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 342, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 879, 883, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 895, 0, 0, 0, 0, 0],
      #[274, 0, 274, 274, 0, 274, 0, 0, 0, 0, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 0, 0, 0, 274, 274, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 859, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 763, 0, 0, 0, 0, 611, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 338, 338, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 338, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 346, 346, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 346, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 0, 0, 0, 0],
      #[0, 0, 0, 0, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 903, 923, 0, 0, 0, 0],
      #[0, 0, 0, 0, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 0, 0, 0, 0],
      #[0, 0, 0, 0, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 903, 911, 0, 0, 0, 0],
      #[0, 0, 0, 0, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 0, 0, 0, 0],
      #[0, 0, 0, 0, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 0, 0, 0, 0],
      #[0, 0, 0, 0, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 0, 0, 0, 0],
      #[278, 0, 278, 278, 0, 278, 0, 0, 0, 0, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 0, 0, 0, 278, 278, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[270, 0, 270, 270, 0, 270, 0, 0, 0, 0, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 0, 0, 0, 270, 270, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 362, 0, 0, 0, 0, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 0, 362, 0, 0, 0, 0, 362, 362, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 763, 0, 0, 0, 0, 611, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 326, 326, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 306, 943, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 503, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 763, 0, 0, 0, 0, 611, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 330, 330, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 859, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 955, 0, 0, 763, 0, 0, 0, 0, 611, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[266, 0, 266, 266, 0, 266, 0, 0, 0, 0, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 0, 0, 0, 266, 266, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 310, 883, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 963, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 0, 0, 0, 0],
      #[0, 0, 0, 0, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 915, 903, 971, 0, 0, 0, 0],
      #[282, 0, 282, 282, 0, 282, 0, 0, 0, 0, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 0, 0, 0, 282, 282, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 979, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[302, 0, 302, 302, 0, 302, 0, 0, 0, 0, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 0, 0, 0, 302, 302, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[654, 0, 654, 654, 0, 654, 0, 0, 0, 0, 654, 654, 654, 654, 654, 654, 654, 654, 654, 654, 654, 654, 654, 654, 654, 0, 0, 0, 654, 654, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[38, 0, 38, 38, 0, 38, 0, 0, 0, 0, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 0, 0, 0, 38, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[999, 0, 11, 15, 0, 179, 0, 0, 0, 0, 51, 39, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 27, 931, 19, 0, 0, 0, 55, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[42, 0, 42, 42, 0, 42, 0, 0, 0, 0, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 0, 0, 0, 42, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 179, 0, 0, 0, 0, 51, 0, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 0, 0, 0, 0, 0, 0, 55, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[1011, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[1019, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 179, 107, 111, 1043, 0, 51, 0, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 0, 0, 0, 0, 0, 0, 55, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[1031, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[1039, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[1047, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 95, 0, 107, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151, 155, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127],
      #[1059, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];

define method production-1
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <SIMPLE-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file -> EOF
  values(265,
         begin
           rhs-1;
         end);
end method production-1;

define method production-2
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <SIMPLE-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file -> file1 EOF
  values(265,
         begin
           rhs-1;
         end);
end method production-2;

define method production-3
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <SIMPLE-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file -> <ALIEN-NAME-TOKEN> type-name EOF
  values(265,
         begin
           rhs-2;
         end);
end method production-3;

define method production-4
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <SIMPLE-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file -> <ALIEN-NAME-TOKEN> identifier EOF
  values(265,
         begin
           element(srcloc-0.objects, rhs-2.string-value, default: #f)
             | parse-error(rhs-2, "Unknown identifier: %s", rhs-2.string-value);
         end);
end method production-4;

define method production-5
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <SIMPLE-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file -> <MACRO-PARSE-TOKEN> type-name EOF
  values(265,
         begin
           rhs-2;
         end);
end method production-5;

define method production-6
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <SIMPLE-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file -> <MACRO-PARSE-TOKEN> constant-expr EOF
  values(265,
         begin
           if (instance?(rhs-2, <identifier-token>))
             element(srcloc-0.objects, rhs-2.string-value, default: #f)
               | parse-error(rhs-2, "Unknown identifier: %s", rhs-2.string-value);
           else
             rhs-2;
           end if;
         end);
end method production-6;

define method production-7
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <LITERAL-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <SIMPLE-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file -> <MACRO-PARSE-TOKEN> <STRING-LITERAL-TOKEN> EOF
  values(265,
         begin
           rhs-2.value;
         end);
end method production-7;

define method production-8
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <SIMPLE-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file -> <CPP-PARSE-TOKEN> constant-expr EOF
  values(265,
         begin
           int-value(rhs-2, srcloc-0);
         end);
end method production-8;

define method production-9
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file1 -> external-definition
  values(247,
         begin
           rhs-1;
         end);
end method production-9;

define method production-10
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file1 -> file1 external-definition
  values(247,
         begin
           rhs-1;
         end);
end method production-10;

define method production-11
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // primary-expr -> identifier
  values(30,
         begin
           // We allow arbitrary identifiers only because they are occasionally
           // permitted by CPP (and treated as integers).  This will also allow a
           // single identifier to pass as a constant expr.  Users of "constant-expr"
           // should be aware of this and call "int-value" to insure that it is in fact
           // a constant value.  "parse-macro" takes advantage of this property of
           // "constant-expr" to allow defined identifiers to be parsed.
           rhs-1;
         end);
end method production-11;

define method production-12
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <LITERAL-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // primary-expr -> <INTEGER-TOKEN>
  values(30,
         begin
           rhs-1.value;
         end);
end method production-12;

define method production-13
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <LITERAL-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // primary-expr -> <CHARACTER-TOKEN>
  values(30,
         begin
           // C evaluates characters as integers in expressions, so we try to parse
           // them as well. This helps particularly with #definies and enums.
           rhs-1.value;
         end);
end method production-13;

define method production-14
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // primary-expr -> <LPAREN-TOKEN> expr <RPAREN-TOKEN>
  values(30,
         begin
           rhs-2;
         end);
end method production-14;

define method production-15
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // primary-expr -> identifier identifier
  values(30,
         begin
           // XXX - We use this to catch preprocessor expressions of the form
           // "defined FOO", which are endemic in the Linux headers and break
           // the original CMU Melange. Let's hope this works.
           // What would be the consequences of making "defined" a keyword?
           if (~instance?(srcloc-0, <parse-cpp-state>) | rhs-1.string-value ~= "defined")
             parse-error(srcloc-0, "Didn't expect to see two identifiers back-to-back.");
           elseif (element(rhs-2.generator.cpp-table, rhs-2.string-value, default: #f))
             1;
           else
             0;
           end;  
         end);
end method production-15;

define method production-16
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // postfix-expr -> primary-expr
  values(35,
         begin
           rhs-1;
         end);
end method production-16;

define method production-17
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // postfix-expr -> postfix-expr <LPAREN-TOKEN> argument-expr-list <RPAREN-TOKEN>
  values(35,
         begin
           // There aren't any compile-time functions which we are prepared to
           // evaluate in general.  However, if we are evaluating an expression on a
           // CPP line, we should be prepared to evaluate the pseudo-function
           // "defined".
           //
           //if (~instance?(srcloc-0, <parse-cpp-state>) | rhs-1.string-value ~= "defined")
           if (rhs-1.string-value ~= "defined")
             let definition = element(rhs-1.generator.cpp-table, rhs-1.string-value,
         			  default: #f);
             if (definition ~= #f)
               if (instance?(definition.head, <token>))	
         	parse-error(srcloc-0,concatenate(rhs-1.string-value, " isn't a parameterized macro."));
               else
         	// XXX: We don't actually substitute here like we should, but
         	// it'll handle "#define __GNUC_PREREQ(maj,min) 0" correctly...
         //	for (token in definition.tail)
         /*	  for (count from 0, param in definition.head)
         	    if (token.string-value = param.string-value)
         	      token := rhs-3[count];
         	    end if;
         	  end for;
         */
         //	  unget-token(rhs-1.generator, token);
         //	end for;
         //	cpp-parse(rhs-1.generator);
                 0; // yeah, chickening out.
               end if;
             else
               parse-error(srcloc-0,"Function calls not allowed in constant expressions.");
             end if;
           elseif (element(rhs-3.generator.cpp-table, rhs-3.string-value, default: #f))
             1;
           else
             0;
           end if;
         end);
end method production-17;

define method production-18
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <NAME-TOKEN>, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // postfix-expr -> <MACHINE-TOKEN> <LPAREN-TOKEN> <IDENTIFIER-TOKEN> <RPAREN-TOKEN>
  values(35,
         begin
           // Handle the solaris "#machine(foo)" construct.  Simply return 0 -- machine
           // types should also be checked via the standard mechanism.
           0;
         end);
end method production-18;

define method production-19
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // argument-expr-list -> assignment-expr
  values(171,
         begin
           rhs-1;
         end);
end method production-19;

define method production-20
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // argument-expr-list -> argument-expr-list <COMMA-TOKEN> assignment-expr
  values(171,
         begin
           rhs-1;
         //  error("argument-expr-list not yet handled.");
         end);
end method production-20;

define method production-21
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // unary-expr -> postfix-expr
  values(52,
         begin
           rhs-1;
         end);
end method production-21;

define method production-22
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // unary-expr -> unary-operator cast-expr
  values(52,
         begin
           select (rhs-1 by instance?)
             <minus-token> => -int-value(rhs-2, srcloc-0);
             <tilde-token> => lognot(int-value(rhs-2, srcloc-0));
             <bang-token> => if (int-value(rhs-2, srcloc-0) == 0) 1 else 0 end if;
           end select;
         end);
end method production-22;

define method production-23
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // unary-expr -> <SIZEOF-TOKEN> <LPAREN-TOKEN> type-name <RPAREN-TOKEN>
  values(52,
         begin
           c-type-size(rhs-3);
         end);
end method production-23;

define method production-24
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // unary-operator -> <MINUS-TOKEN>
  values(40,
         begin
           rhs-1;
         end);
end method production-24;

define method production-25
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // unary-operator -> <TILDE-TOKEN>
  values(40,
         begin
           rhs-1;
         end);
end method production-25;

define method production-26
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // unary-operator -> <BANG-TOKEN>
  values(40,
         begin
           rhs-1;
         end);
end method production-26;

define method production-27
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // cast-expr -> unary-expr
  values(select (prev-state)
           110 => 111;
           60 => 61;
           58 => 59;
           56 => 57;
           40 => 169;
           OTHERWISE => 54;
         end,
         begin
           rhs-1;
         end);
end method production-27;

define method production-28
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>,
     rhs-4, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // cast-expr -> <LPAREN-TOKEN> type-name <RPAREN-TOKEN> cast-expr
  values(select (prev-state)
           110 => 111;
           60 => 61;
           58 => 59;
           56 => 57;
           40 => 169;
           OTHERWISE => 54;
         end,
         begin
           let result = int-value(rhs-4, srcloc-0);
           if (instance?(result, <integer>)
                 & instance?(rhs-2.true-type, <integer-type-declaration>))
             // Handle casting a large unsigned value to a signed integer type.
             if (instance?(rhs-2.true-type, <signed-integer-type-declaration>)
                   & result > (2 ^ (8 * rhs-2.type-size-slot - 1) - 1))
               as(<integer>, result - as(<integer>, 2) ^ (8 * rhs-2.type-size-slot))
             else
               result
             end if
           else
             parse-error
               (srcloc-0,
                "Melange only handles compile time casts from integer to integer");
           end if;
         end);
end method production-28;

define method production-29
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // multiplicative-expr -> cast-expr
  values(select (prev-state)
           65 => 66;
           63 => 64;
           OTHERWISE => 55;
         end,
         begin
           rhs-1;
         end);
end method production-29;

define method production-30
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // multiplicative-expr -> multiplicative-expr <STAR-TOKEN> cast-expr
  values(select (prev-state)
           65 => 66;
           63 => 64;
           OTHERWISE => 55;
         end,
         begin
           int-value(rhs-1, srcloc-0) * int-value(rhs-3, srcloc-0);
         end);
end method production-30;

define method production-31
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // multiplicative-expr -> multiplicative-expr <SLASH-TOKEN> cast-expr
  values(select (prev-state)
           65 => 66;
           63 => 64;
           OTHERWISE => 55;
         end,
         begin
           truncate/(int-value(rhs-1, srcloc-0), int-value(rhs-3, srcloc-0));
         end);
end method production-31;

define method production-32
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // multiplicative-expr -> multiplicative-expr <PERCENT-TOKEN> cast-expr
  values(select (prev-state)
           65 => 66;
           63 => 64;
           OTHERWISE => 55;
         end,
         begin
           remainder(int-value(rhs-1, srcloc-0), int-value(rhs-3, srcloc-0));
         end);
end method production-32;

define method production-33
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // additive-expr -> multiplicative-expr
  values(select (prev-state)
           70 => 71;
           68 => 69;
           OTHERWISE => 62;
         end,
         begin
           rhs-1;
         end);
end method production-33;

define method production-34
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // additive-expr -> additive-expr <PLUS-TOKEN> multiplicative-expr
  values(select (prev-state)
           70 => 71;
           68 => 69;
           OTHERWISE => 62;
         end,
         begin
           int-value(rhs-1, srcloc-0) + int-value(rhs-3, srcloc-0);
         end);
end method production-34;

define method production-35
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // additive-expr -> additive-expr <MINUS-TOKEN> multiplicative-expr
  values(select (prev-state)
           70 => 71;
           68 => 69;
           OTHERWISE => 62;
         end,
         begin
           int-value(rhs-1, srcloc-0) - int-value(rhs-3, srcloc-0);
         end);
end method production-35;

define method production-36
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // shift-expr -> additive-expr
  values(select (prev-state)
           79 => 80;
           77 => 78;
           75 => 76;
           73 => 74;
           OTHERWISE => 67;
         end,
         begin
           rhs-1;
         end);
end method production-36;

define method production-37
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // shift-expr -> shift-expr <LEFT-OP-TOKEN> additive-expr
  values(select (prev-state)
           79 => 80;
           77 => 78;
           75 => 76;
           73 => 74;
           OTHERWISE => 67;
         end,
         begin
           ash(int-value(rhs-1, srcloc-0), int-value(rhs-3, srcloc-0))
         end);
end method production-37;

define method production-38
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // shift-expr -> shift-expr <RIGHT-OP-TOKEN> additive-expr
  values(select (prev-state)
           79 => 80;
           77 => 78;
           75 => 76;
           73 => 74;
           OTHERWISE => 67;
         end,
         begin
           ash(int-value(rhs-1, srcloc-0), -int-value(rhs-3, srcloc-0))
         end);
end method production-38;

define method production-39
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // relational-expr -> shift-expr
  values(select (prev-state)
           84 => 85;
           82 => 83;
           OTHERWISE => 72;
         end,
         begin
           rhs-1;
         end);
end method production-39;

define method production-40
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // relational-expr -> relational-expr <LT-TOKEN> shift-expr
  values(select (prev-state)
           84 => 85;
           82 => 83;
           OTHERWISE => 72;
         end,
         begin
           if (int-value(rhs-1, srcloc-0) < int-value(rhs-3, srcloc-0)) 1 else 0 end if;
         end);
end method production-40;

define method production-41
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // relational-expr -> relational-expr <GT-TOKEN> shift-expr
  values(select (prev-state)
           84 => 85;
           82 => 83;
           OTHERWISE => 72;
         end,
         begin
           if (int-value(rhs-1, srcloc-0) > int-value(rhs-3, srcloc-0)) 1 else 0 end if;
         end);
end method production-41;

define method production-42
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // relational-expr -> relational-expr <LE-OP-TOKEN> shift-expr
  values(select (prev-state)
           84 => 85;
           82 => 83;
           OTHERWISE => 72;
         end,
         begin
           if (int-value(rhs-1, srcloc-0) <= int-value(rhs-3, srcloc-0)) 1 else 0 end if;
         end);
end method production-42;

define method production-43
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // relational-expr -> relational-expr <GE-OP-TOKEN> shift-expr
  values(select (prev-state)
           84 => 85;
           82 => 83;
           OTHERWISE => 72;
         end,
         begin
           if (int-value(rhs-1, srcloc-0) >= int-value(rhs-3, srcloc-0)) 1 else 0 end if;
         end);
end method production-43;

define method production-44
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // equality-expr -> relational-expr
  values(select (prev-state)
           87 => 88;
           OTHERWISE => 81;
         end,
         begin
           rhs-1;
         end);
end method production-44;

define method production-45
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // equality-expr -> equality-expr <EQ-OP-TOKEN> relational-expr
  values(select (prev-state)
           87 => 88;
           OTHERWISE => 81;
         end,
         begin
           if (int-value(rhs-1, srcloc-0) == int-value(rhs-3, srcloc-0)) 1 else 0 end if;
         end);
end method production-45;

define method production-46
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // equality-expr -> equality-expr <NE-OP-TOKEN> relational-expr
  values(select (prev-state)
           87 => 88;
           OTHERWISE => 81;
         end,
         begin
           if (int-value(rhs-1, srcloc-0) ~= int-value(rhs-3, srcloc-0)) 1 else 0 end if;
         end);
end method production-46;

define method production-47
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // and-expr -> equality-expr
  values(select (prev-state)
           90 => 91;
           OTHERWISE => 86;
         end,
         begin
           rhs-1;
         end);
end method production-47;

define method production-48
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // and-expr -> and-expr <AMPERSAND-TOKEN> equality-expr
  values(select (prev-state)
           90 => 91;
           OTHERWISE => 86;
         end,
         begin
           logand(int-value(rhs-1, srcloc-0), int-value(rhs-3, srcloc-0))
         end);
end method production-48;

define method production-49
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // exclusive-or-expr -> and-expr
  values(select (prev-state)
           93 => 94;
           OTHERWISE => 89;
         end,
         begin
           rhs-1;
         end);
end method production-49;

define method production-50
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // exclusive-or-expr -> exclusive-or-expr <CARAT-TOKEN> and-expr
  values(select (prev-state)
           93 => 94;
           OTHERWISE => 89;
         end,
         begin
           logxor(int-value(rhs-1, srcloc-0), int-value(rhs-3, srcloc-0));
         end);
end method production-50;

define method production-51
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // inclusive-or-expr -> exclusive-or-expr
  values(select (prev-state)
           96 => 97;
           OTHERWISE => 92;
         end,
         begin
           rhs-1;
         end);
end method production-51;

define method production-52
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // inclusive-or-expr -> inclusive-or-expr <BAR-TOKEN> exclusive-or-expr
  values(select (prev-state)
           96 => 97;
           OTHERWISE => 92;
         end,
         begin
           logior(int-value(rhs-1, srcloc-0), int-value(rhs-3, srcloc-0));
         end);
end method production-52;

define method production-53
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // logical-and-expr -> inclusive-or-expr
  values(select (prev-state)
           99 => 100;
           OTHERWISE => 95;
         end,
         begin
           rhs-1;
         end);
end method production-53;

define method production-54
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // logical-and-expr -> logical-and-expr <AND-OP-TOKEN> inclusive-or-expr
  values(select (prev-state)
           99 => 100;
           OTHERWISE => 95;
         end,
         begin
           if (int-value(rhs-1, srcloc-0) == 0) rhs-1 else rhs-3 end if;
         end);
end method production-54;

define method production-55
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // logical-or-expr -> logical-and-expr
  values(select (prev-state)
           101 => 102;
           OTHERWISE => 98;
         end,
         begin
           rhs-1;
         end);
end method production-55;

define method production-56
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // logical-or-expr -> logical-or-expr <OR-OP-TOKEN> logical-and-expr
  values(select (prev-state)
           101 => 102;
           OTHERWISE => 98;
         end,
         begin
           if (int-value(rhs-1, srcloc-0) == 0) rhs-3 else rhs-1 end if;
         end);
end method production-56;

define method production-57
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // conditional-expr -> logical-or-expr
  values(select (prev-state)
           172 => 105;
           103 => 104;
           53 => 105;
           36 => 105;
           OTHERWISE => 112;
         end,
         begin
           rhs-1;
         end);
end method production-57;

define method production-58
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>,
     rhs-5, srcloc-5 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // conditional-expr -> logical-or-expr <QUESTION-TOKEN> logical-or-expr <COLON-TOKEN> conditional-expr
  values(select (prev-state)
           172 => 105;
           103 => 104;
           53 => 105;
           36 => 105;
           OTHERWISE => 112;
         end,
         begin
           if (int-value(rhs-1, srcloc-0) == 0) rhs-5 else rhs-3 end if;
         end);
end method production-58;

define method production-59
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // assignment-expr -> conditional-expr
  values(select (prev-state)
           172 => 173;
           53 => 106;
           OTHERWISE => 170;
         end,
         begin
           rhs-1;
         end);
end method production-59;

define method production-60
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // expr -> assignment-expr
  values(107,
         begin
           rhs-1;
         end);
end method production-60;

define method production-61
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // constant-expr -> conditional-expr
  values(select (prev-state)
           262 => 263;
           255 => 258;
           193 => 194;
           188 => 189;
           127 => 129;
           117 => 119;
           50 => 113;
           OTHERWISE => 175;
         end,
         begin
           // In general, constant expr will return an integer value.  However, for
           // obscure reasons, we also allow it to return a single identifier.
           rhs-1;
         end);
end method production-61;

define method production-62
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // lcurly-element -> <LCURLY-TOKEN> curly-list <RCURLY-TOKEN>
  values(229,
         begin
           #f;
         end);
end method production-62;

define method production-63
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // lcurly-element -> NON-CURLY
  values(229,
         begin
           #f;
         end);
end method production-63;

define method production-64
    (prev-state :: <integer>, srcloc-0 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // curly-list -> epsilon
  values(select (prev-state)
           240 => 241;
           225 => 226;
           OTHERWISE => 224;
         end,
         begin
           #f;
         end);
end method production-64;

define method production-65
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // curly-list -> curly-list lcurly-element
  values(select (prev-state)
           240 => 241;
           225 => 226;
           OTHERWISE => 224;
         end,
         begin
           #f;
         end);
end method production-65;

define method production-66
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declaration -> declaration-specifiers <SEMICOLON-TOKEN>
  values(245,
         begin
           *typedef-flag* := #f;
           process-type-list(rhs-1, srcloc-0);
         end);
end method production-66;

define method production-67
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declaration -> inline-declaration
  values(245,
         begin
           #f;
         end);
end method production-67;

define method production-68
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // inline-declaration -> inline-specifiers declaration-specifiers extended-declarator-list <SEMICOLON-TOKEN>
  values(231,
         begin
           let type = process-type-list(rhs-2, srcloc-0);
           let names = reverse!(rhs-3);
           declare-objects(srcloc-0, type, names, *typedef-flag*);
           *typedef-flag* := #f;
         end);
end method production-68;

define method production-69
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>,
     rhs-5, srcloc-5 :: <source-location>,
     rhs-6 :: <PUNCTUATION-TOKEN>, srcloc-6 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // inline-declaration -> inline-specifiers declaration-specifiers extended-declarator-list <LCURLY-TOKEN> curly-list <RCURLY-TOKEN>
  values(231,
         begin
           let type = process-type-list(rhs-2, srcloc-0);
           let names = reverse!(rhs-3);
           declare-objects(srcloc-0, type, names, *typedef-flag*);
           *typedef-flag* := #f;
         end);
end method production-69;

define method production-70
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>,
     rhs-4, srcloc-4 :: <source-location>,
     rhs-5 :: <PUNCTUATION-TOKEN>, srcloc-5 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // inline-declaration -> declaration-specifiers extended-declarator-list <LCURLY-TOKEN> curly-list <RCURLY-TOKEN>
  values(231,
         begin
           let type = process-type-list(rhs-1, srcloc-0);
           let names = reverse!(rhs-2);
           declare-objects(srcloc-0, type, names, *typedef-flag*);
           *typedef-flag* := #f;
         end);
end method production-70;

define method production-71
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // inline-specifiers -> <INLINE-TOKEN>
  values(8,
         begin
           rhs-1;
         end);
end method production-71;

define method production-72
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // inline-specifiers -> <STATIC-TOKEN>
  values(8,
         begin
           // XXX - This rule might allow 'static extern', which is
           // clearly illegal. But we're going to ignore it, so why bother?
           // This should go away when we handle static storage specifiers.
           rhs-1;
         end);
end method production-72;

define method production-73
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <RESERVED-WORD-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // inline-specifiers -> <STATIC-TOKEN> <INLINE-TOKEN>
  values(8,
         begin
           // Bogus declarations of this form appear in Gtk+.
           // XXX - This rule might allow 'static inline extern', which is
           // clearly illegal. But we're going to ignore it, so why bother?
           rhs-2;
         end);
end method production-73;

define method production-74
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <RESERVED-WORD-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // inline-specifiers -> <INLINE-TOKEN> <STATIC-TOKEN>
  values(8,
         begin
           // XXX - This rule might allow 'inline static extern', which is
           // clearly illegal. But we're going to ignore it, so why bother?
           // This should go away when we handle static storage specifiers.
           rhs-1;
         end);
end method production-74;

define method production-75
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declaration -> declaration-aux <SEMICOLON-TOKEN>
  values(245,
         begin
           // We use an auxiliary production so that it can be reduced and
           // the add-typedef function called before the first token of the following
           // declaration is read.
           rhs-1;
         end);
end method production-75;

define method production-76
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declaration-aux -> <EXTERN-TOKEN> init-declarator-list
  values(243,
         begin
           // Storage class must be extern; unspecified type must be "int"
           let spec = list(make(<int-token>, generator: rhs-1.generator, string: "int"));
           let type = process-type-list(spec, srcloc-0);
           let names = reverse!(rhs-2);
           declare-objects(srcloc-0, type, names, *typedef-flag*);
           *typedef-flag* := #f;
         end);
end method production-76;

define method production-77
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declaration-aux -> declaration-specifiers extended-declarator-list
  values(243,
         begin
           let type = process-type-list(rhs-1, srcloc-0);
           let names = reverse!(rhs-2);
           declare-objects(srcloc-0, type, names, *typedef-flag*);
           *typedef-flag* := #f;
         end);
end method production-77;

define method production-78
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declaration-specifiers -> storage-class-specifier declaration-specifiers
  values(select (prev-state)
           11 => 211;
           8 => 212;
           OTHERWISE => 237;
         end,
         begin
           // Storage class must be extern -- no need to note it
           rhs-2;
         end);
end method production-78;

define method production-79
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declaration-specifiers -> type-specifier
  values(select (prev-state)
           11 => 211;
           8 => 212;
           OTHERWISE => 237;
         end,
         begin
           list(rhs-1);
         end);
end method production-79;

define method production-80
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declaration-specifiers -> numeric-specifier
  values(select (prev-state)
           11 => 211;
           8 => 212;
           OTHERWISE => 237;
         end,
         begin
           rhs-1;
         end);
end method production-80;

define method production-81
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // init-declarator-list -> declarator
  values(234,
         begin
           list(rhs-1);
         end);
end method production-81;

define method production-82
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // init-declarator-list -> init-declarator-list <COMMA-TOKEN> declarator
  values(234,
         begin
           pair(rhs-3, rhs-1);
         end);
end method production-82;

define method production-83
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // extended-declarator-list -> declarator
  values(select (prev-state)
           237 => 239;
           OTHERWISE => 218;
         end,
         begin
           // This hack is necessary because VC++ lets you redeclare typedefs.  Bad
           // idea!  Don't look for clean logic or robustness -- that would require
           // more work than MS deserves.
           list(rhs-1);
         end);
end method production-83;

define method production-84
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // extended-declarator-list -> extended-declarator-list <COMMA-TOKEN> declarator
  values(select (prev-state)
           237 => 239;
           OTHERWISE => 218;
         end,
         begin
           // see above.
           pair(rhs-3, rhs-1);
         end);
end method production-84;

define method production-85
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // extended-declarator-list -> extended-declarator
  values(select (prev-state)
           237 => 239;
           OTHERWISE => 218;
         end,
         begin
           list(rhs-1);
         end);
end method production-85;

define method production-86
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // extended-declarator-list -> extended-declarator-list <COMMA-TOKEN> extended-declarator
  values(select (prev-state)
           237 => 239;
           OTHERWISE => 218;
         end,
         begin
           // see above.
           pair(rhs-3, rhs-1);
         end);
end method production-86;

define method production-87
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <NAME-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // extended-declarator -> <TYPE-NAME-TOKEN>
  values(select (prev-state)
           220 => 222;
           OTHERWISE => 217;
         end,
         begin
           // see above.
           rhs-1;
         end);
end method production-87;

define method production-88
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <NAME-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // extended-declarator -> pointer <TYPE-NAME-TOKEN>
  values(select (prev-state)
           220 => 222;
           OTHERWISE => 217;
         end,
         begin
           // see above.
           pair(rhs-1, rhs-2);
         end);
end method production-88;

define method production-89
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // storage-class-specifier -> <TYPEDEF-TOKEN>
  values(11,
         begin
           *typedef-flag* := #t;
           rhs-1;
         end);
end method production-89;

define method production-90
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // storage-class-specifier -> <EXTERN-TOKEN>
  values(11,
         begin
           rhs-1;
         end);
end method production-90;

define method production-91
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <TYPE-SPECIFIER-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // numeric-specifier -> TYPE-SPEC
  values(select (prev-state)
           247 => 210;
           46 => 47;
           11 => 210;
           8 => 210;
           0 => 210;
           OTHERWISE => 48;
         end,
         begin
           list(rhs-1);
         end);
end method production-91;

define method production-92
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <TYPE-SPECIFIER-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // numeric-specifier -> TYPE-SPEC numeric-specifier
  values(select (prev-state)
           247 => 210;
           46 => 47;
           11 => 210;
           8 => 210;
           0 => 210;
           OTHERWISE => 48;
         end,
         begin
           pair(rhs-1, rhs-2);
         end);
end method production-92;

define method production-93
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // type-specifier -> struct-or-union-specifier
  values(select (prev-state)
           247 => 209;
           11 => 209;
           8 => 209;
           0 => 209;
           OTHERWISE => 45;
         end,
         begin
           rhs-1;
         end);
end method production-93;

define method production-94
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // type-specifier -> enum-specifier
  values(select (prev-state)
           247 => 209;
           11 => 209;
           8 => 209;
           0 => 209;
           OTHERWISE => 45;
         end,
         begin
           rhs-1;
         end);
end method production-94;

define method production-95
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <NAME-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // type-specifier -> <TYPE-NAME-TOKEN>
  values(select (prev-state)
           247 => 209;
           11 => 209;
           8 => 209;
           0 => 209;
           OTHERWISE => 45;
         end,
         begin
           srcloc-0.objects[rhs-1.value];
         end);
end method production-95;

define method production-96
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <NAME-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>,
     rhs-4, srcloc-4 :: <source-location>,
     rhs-5 :: <PUNCTUATION-TOKEN>, srcloc-5 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-or-union-specifier -> struct-or-union NAME <LCURLY-TOKEN> struct-declaration-list <RCURLY-TOKEN>
  values(16,
         begin
           make-struct-type(rhs-2.value, rhs-4, rhs-1, srcloc-0);
         end);
end method production-96;

define method production-97
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-or-union-specifier -> struct-or-union <LCURLY-TOKEN> struct-declaration-list <RCURLY-TOKEN>
  values(16,
         begin
           make-struct-type(#f, rhs-3, rhs-1, srcloc-0);
         end);
end method production-97;

define method production-98
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <NAME-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-or-union-specifier -> struct-or-union NAME
  values(16,
         begin
           make-struct-type(rhs-2.value, #f, rhs-1, srcloc-0);
         end);
end method production-98;

define method production-99
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-or-union -> <STRUCT-TOKEN>
  values(14,
         begin
           rhs-1;
         end);
end method production-99;

define method production-100
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-or-union -> <UNION-TOKEN>
  values(14,
         begin
           rhs-1;
         end);
end method production-100;

define method production-101
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-declaration-list -> struct-declaration
  values(select (prev-state)
           206 => 207;
           OTHERWISE => 202;
         end,
         begin
           rhs-1;
         end);
end method production-101;

define method production-102
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-declaration-list -> struct-declaration-list struct-declaration
  values(select (prev-state)
           206 => 207;
           OTHERWISE => 202;
         end,
         begin
           // Creates list in normal order.
           concatenate(rhs-1, rhs-2);
         end);
end method production-102;

define method production-103
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-declaration -> type-specifier-list struct-declarator-list <SEMICOLON-TOKEN>
  values(select (prev-state)
           207 => 203;
           202 => 203;
           OTHERWISE => 201;
         end,
         begin
           let type = process-type-list(reverse!(rhs-1), srcloc-0);
           let return = #();
           for (declarator in rhs-2)
             let (type, name) = process-declarator(type, declarator, srcloc-0);
             return := pair(pair(name & name.value, type), return);
           end for;
           return;
         end);
end method production-103;

define method production-104
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-declaration -> type-specifier-list <SEMICOLON-TOKEN>
  values(select (prev-state)
           207 => 203;
           202 => 203;
           OTHERWISE => 201;
         end,
         begin
           let type = process-type-list(reverse!(rhs-1), srcloc-0);
           list(pair("_anon_field", type));
         end);
end method production-104;

define method production-105
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-declarator-list -> struct-declarator
  values(196,
         begin
           list(rhs-1);
         end);
end method production-105;

define method production-106
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-declarator-list -> struct-declarator-list <COMMA-TOKEN> struct-declarator
  values(196,
         begin
           // Creates list in reverse order.
           pair(rhs-3, rhs-1);
         end);
end method production-106;

define method production-107
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-declarator -> declarator
  values(select (prev-state)
           197 => 198;
           OTHERWISE => 195;
         end,
         begin
           rhs-1;
         end);
end method production-107;

define method production-108
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-declarator -> <COLON-TOKEN> constant-expr
  values(select (prev-state)
           197 => 198;
           OTHERWISE => 195;
         end,
         begin
           pair(#"bitfield", pair(int-value(rhs-2, srcloc-0), #f));
         end);
end method production-108;

define method production-109
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // struct-declarator -> declarator <COLON-TOKEN> constant-expr
  values(select (prev-state)
           197 => 198;
           OTHERWISE => 195;
         end,
         begin
           pair(#"bitfield", pair(int-value(rhs-3, srcloc-0), rhs-1));
         end);
end method production-109;

define method production-110
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // enum-specifier -> <ENUM-TOKEN> enum-elements
  values(43,
         begin
           make-struct-type(#f, rhs-2, rhs-1, srcloc-0);
         end);
end method production-110;

define method production-111
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <NAME-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // enum-specifier -> <ENUM-TOKEN> NAME enum-elements
  values(43,
         begin
           make-struct-type(rhs-2.value, rhs-3, rhs-1, srcloc-0);
         end);
end method production-111;

define method production-112
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <NAME-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // enum-specifier -> <ENUM-TOKEN> NAME
  values(43,
         begin
           make-struct-type(rhs-2.value, #f, rhs-1, srcloc-0);
         end);
end method production-112;

define method production-113
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // enum-elements -> <LCURLY-TOKEN> <RCURLY-TOKEN>
  values(select (prev-state)
           185 => 186;
           OTHERWISE => 184;
         end,
         begin
           #()
         end);
end method production-113;

define method production-114
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4, srcloc-4 :: <source-location>,
     rhs-5 :: <PUNCTUATION-TOKEN>, srcloc-5 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // enum-elements -> <LCURLY-TOKEN> internal-include-boundary enumerator-list internal-include-boundary <RCURLY-TOKEN>
  values(select (prev-state)
           185 => 186;
           OTHERWISE => 184;
         end,
         begin
           reverse!(rhs-3);
         end);
end method production-114;

define method production-115
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4, srcloc-4 :: <source-location>,
     rhs-5 :: <PUNCTUATION-TOKEN>, srcloc-5 :: <source-location>,
     rhs-6, srcloc-6 :: <source-location>,
     rhs-7 :: <PUNCTUATION-TOKEN>, srcloc-7 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // enum-elements -> <LCURLY-TOKEN> internal-include-boundary enumerator-list internal-include-boundary <COMMA-TOKEN> internal-include-boundary <RCURLY-TOKEN>
  values(select (prev-state)
           185 => 186;
           OTHERWISE => 184;
         end,
         begin
           reverse!(rhs-3);
         end);
end method production-115;

define method production-116
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // enumerator-list -> enumerator
  values(177,
         begin
           list(make-enum-slot(rhs-1.head, rhs-1.tail, #f, srcloc-0));
         end);
end method production-116;

define method production-117
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>,
     rhs-4, srcloc-4 :: <source-location>,
     rhs-5, srcloc-5 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // enumerator-list -> enumerator-list internal-include-boundary <COMMA-TOKEN> internal-include-boundary enumerator
  values(177,
         begin
           // HACK: We depend here on the fact that this parser generator evaluates
           // the subtrees left-to-right.
           //
           // We do all of this on the fly because some (i.e. Apple's) C compilers
           // let later enum values be computed based upon those earlier in the 
           // same enum declaration.
           pair(make-enum-slot(rhs-5.head, rhs-5.tail, rhs-1.head, srcloc-0), rhs-1);
         end);
end method production-117;

define method production-118
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // enumerator -> identifier
  values(select (prev-state)
           181 => 182;
           OTHERWISE => 176;
         end,
         begin
           pair(rhs-1.value, #f);
         end);
end method production-118;

define method production-119
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // enumerator -> identifier <ASSIGN-TOKEN> constant-expr
  values(select (prev-state)
           181 => 182;
           OTHERWISE => 176;
         end,
         begin
           pair(rhs-1.value, int-value(rhs-3, srcloc-0));
         end);
end method production-119;

define method production-120
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declarator -> declarator2
  values(select (prev-state)
           237 => 213;
           235 => 236;
           232 => 233;
           220 => 221;
           212 => 213;
           197 => 192;
           187 => 192;
           123 => 148;
           OTHERWISE => 150;
         end,
         begin
           rhs-1;
         end);
end method production-120;

define method production-121
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declarator -> pointer declarator2
  values(select (prev-state)
           237 => 213;
           235 => 236;
           232 => 233;
           220 => 221;
           212 => 213;
           197 => 192;
           187 => 192;
           123 => 148;
           OTHERWISE => 150;
         end,
         begin
           pair(rhs-1, rhs-2);
         end);
end method production-121;

define method production-122
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declarator2 -> identifier
  values(select (prev-state)
           215 => 155;
           191 => 155;
           154 => 155;
           OTHERWISE => 126;
         end,
         begin
           rhs-1;
         end);
end method production-122;

define method production-123
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <NAME-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declarator2 -> <TYPE-NAME-TOKEN>
  values(select (prev-state)
           215 => 155;
           191 => 155;
           154 => 155;
           OTHERWISE => 126;
         end,
         begin
           rhs-1;
         end);
end method production-123;

define method production-124
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declarator2 -> <LPAREN-TOKEN> declarator <RPAREN-TOKEN>
  values(select (prev-state)
           215 => 155;
           191 => 155;
           154 => 155;
           OTHERWISE => 126;
         end,
         begin
           rhs-2
         end);
end method production-124;

define method production-125
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declarator2 -> declarator2 <LBRACKET-TOKEN> <RBRACKET-TOKEN>
  values(select (prev-state)
           215 => 155;
           191 => 155;
           154 => 155;
           OTHERWISE => 126;
         end,
         begin
           pair(#"vector", pair(#f, rhs-1));
         end);
end method production-125;

define method production-126
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declarator2 -> declarator2 <LBRACKET-TOKEN> constant-expr <RBRACKET-TOKEN>
  values(select (prev-state)
           215 => 155;
           191 => 155;
           154 => 155;
           OTHERWISE => 126;
         end,
         begin
           pair(#"vector", pair(int-value(rhs-3, srcloc-0), rhs-1));
         end);
end method production-126;

define method production-127
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declarator2 -> declarator2 <LPAREN-TOKEN> <RPAREN-TOKEN>
  values(select (prev-state)
           215 => 155;
           191 => 155;
           154 => 155;
           OTHERWISE => 126;
         end,
         begin
           pair(#"function", pair(list(make(<varargs-declaration>,
                                            name: "", type: unknown-type)), rhs-1));
         end);
end method production-127;

define method production-128
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declarator2 -> declarator2 <LPAREN-TOKEN> parameter-type-list <RPAREN-TOKEN>
  values(select (prev-state)
           215 => 155;
           191 => 155;
           154 => 155;
           OTHERWISE => 126;
         end,
         begin
           pair(#"function", pair(reverse!(rhs-3), rhs-1));
         end);
end method production-128;

define method production-129
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // declarator2 -> declarator2 <LPAREN-TOKEN> parameter-identifier-list <RPAREN-TOKEN>
  values(select (prev-state)
           215 => 155;
           191 => 155;
           154 => 155;
           OTHERWISE => 126;
         end,
         begin
           pair(#"function", pair(reverse!(rhs-3), rhs-1));
         end);
end method production-129;

define method production-130
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // pointer -> <STAR-TOKEN>
  values(select (prev-state)
           237 => 215;
           220 => 215;
           212 => 215;
           152 => 153;
           149 => 154;
           123 => 154;
           115 => 166;
           49 => 166;
           OTHERWISE => 191;
         end,
         begin
           list(#"pointer");
         end);
end method production-130;

define method production-131
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // pointer -> <STAR-TOKEN> pointer
  values(select (prev-state)
           237 => 215;
           220 => 215;
           212 => 215;
           152 => 153;
           149 => 154;
           123 => 154;
           115 => 166;
           49 => 166;
           OTHERWISE => 191;
         end,
         begin
           pair(#"pointer", rhs-2);
         end);
end method production-131;

define method production-132
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // type-specifier-list -> type-specifier
  values(select (prev-state)
           255 => 49;
           250 => 49;
           207 => 187;
           206 => 187;
           202 => 187;
           53 => 49;
           42 => 49;
           15 => 187;
           OTHERWISE => 123;
         end,
         begin
           list(rhs-1);
         end);
end method production-132;

define method production-133
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // type-specifier-list -> numeric-specifier
  values(select (prev-state)
           255 => 49;
           250 => 49;
           207 => 187;
           206 => 187;
           202 => 187;
           53 => 49;
           42 => 49;
           15 => 187;
           OTHERWISE => 123;
         end,
         begin
           reverse!(rhs-1);
         end);
end method production-133;

define method production-134
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // parameter-identifier-list -> identifier-list
  values(146,
         begin
           rhs-1;
         end);
end method production-134;

define method production-135
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // parameter-identifier-list -> identifier-list <COMMA-TOKEN> <ELLIPSIS-TOKEN>
  values(146,
         begin
           pair(make(<varargs-declaration>, name: "", type: unknown-type), rhs-1);
         end);
end method production-135;

define method production-136
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // identifier-list -> identifier
  values(142,
         begin
           list(make(<arg-declaration>, name: rhs-1.string-value, type: unknown-type));
         end);
end method production-136;

define method production-137
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // identifier-list -> identifier-list <COMMA-TOKEN> identifier
  values(142,
         begin
           // Produces list in reverse order.
           pair(make(<arg-declaration>, name: rhs-3.string-value, type: unknown-type),
                rhs-1);
         end);
end method production-137;

define method production-138
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // parameter-type-list -> parameter-list
  values(select (prev-state)
           131 => 139;
           121 => 164;
           OTHERWISE => 161;
         end,
         begin
           rhs-1;
         end);
end method production-138;

define method production-139
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // parameter-type-list -> parameter-list <COMMA-TOKEN> <ELLIPSIS-TOKEN>
  values(select (prev-state)
           131 => 139;
           121 => 164;
           OTHERWISE => 161;
         end,
         begin
           pair(make(<varargs-declaration>, name: "", type: unknown-type), rhs-1);
         end);
end method production-139;

define method production-140
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // parameter-list -> parameter-declaration
  values(135,
         begin
           list(rhs-1);
         end);
end method production-140;

define method production-141
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // parameter-list -> parameter-list <COMMA-TOKEN> parameter-declaration
  values(135,
         begin
           // Produces lists in reverse order.
           pair(rhs-3, rhs-1);
         end);
end method production-141;

define method production-142
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // parameter-declaration -> type-specifier-list declarator
  values(select (prev-state)
           136 => 137;
           OTHERWISE => 134;
         end,
         begin
           let type = process-type-list(reverse!(rhs-1), srcloc-0);
           let (type, name) = process-declarator(type, rhs-2, srcloc-0);
           make(<arg-declaration>, name: name.string-value, type: type);
         end);
end method production-142;

define method production-143
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // parameter-declaration -> type-name
  values(select (prev-state)
           136 => 137;
           OTHERWISE => 134;
         end,
         begin
           make(<arg-declaration>, name: "", type: rhs-1);
         end);
end method production-143;

define method production-144
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // type-name -> type-specifier-list
  values(select (prev-state)
           255 => 256;
           250 => 251;
           53 => 109;
           42 => 167;
           OTHERWISE => 133;
         end,
         begin
           process-type-list(reverse!(rhs-1), srcloc-0);
         end);
end method production-144;

define method production-145
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // type-name -> type-specifier-list abstract-declarator
  values(select (prev-state)
           255 => 256;
           250 => 251;
           53 => 109;
           42 => 167;
           OTHERWISE => 133;
         end,
         begin
           let type = process-type-list(reverse!(rhs-1), srcloc-0);
           let (type, name) = process-declarator(type, rhs-2, srcloc-0);
           type;
         end);
end method production-145;

define method production-146
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator -> pointer
  values(select (prev-state)
           149 => 157;
           115 => 157;
           OTHERWISE => 163;
         end,
         begin
           list(rhs-1);
         end);
end method production-146;

define method production-147
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator -> abstract-declarator2
  values(select (prev-state)
           149 => 157;
           115 => 157;
           OTHERWISE => 163;
         end,
         begin
           rhs-1;
         end);
end method production-147;

define method production-148
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator -> pointer abstract-declarator2
  values(select (prev-state)
           149 => 157;
           115 => 157;
           OTHERWISE => 163;
         end,
         begin
           pair(rhs-1, rhs-2);
         end);
end method production-148;

define method production-149
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator2 -> <LPAREN-TOKEN> abstract-declarator <RPAREN-TOKEN>
  values(select (prev-state)
           166 => 156;
           154 => 156;
           OTHERWISE => 116;
         end,
         begin
           rhs-2;
         end);
end method production-149;

define method production-150
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator2 -> <LBRACKET-TOKEN> <RBRACKET-TOKEN>
  values(select (prev-state)
           166 => 156;
           154 => 156;
           OTHERWISE => 116;
         end,
         begin
           list(#"vector", #f);
         end);
end method production-150;

define method production-151
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator2 -> <LBRACKET-TOKEN> constant-expr <RBRACKET-TOKEN>
  values(select (prev-state)
           166 => 156;
           154 => 156;
           OTHERWISE => 116;
         end,
         begin
           list(#"vector", int-value(rhs-2, srcloc-0));
         end);
end method production-151;

define method production-152
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator2 -> abstract-declarator2 <LBRACKET-TOKEN> <RBRACKET-TOKEN>
  values(select (prev-state)
           166 => 156;
           154 => 156;
           OTHERWISE => 116;
         end,
         begin
           pair(#"vector", pair(#f, rhs-1));
         end);
end method production-152;

define method production-153
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator2 -> abstract-declarator2 <LBRACKET-TOKEN> constant-expr <RBRACKET-TOKEN>
  values(select (prev-state)
           166 => 156;
           154 => 156;
           OTHERWISE => 116;
         end,
         begin
           pair(#"vector", pair(int-value(rhs-3, srcloc-0), rhs-1));
         end);
end method production-153;

define method production-154
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator2 -> <LPAREN-TOKEN> <RPAREN-TOKEN>
  values(select (prev-state)
           166 => 156;
           154 => 156;
           OTHERWISE => 116;
         end,
         begin
           list(#"function",
                list(make(<varargs-declaration>, name: "", type: unknown-type)));
         end);
end method production-154;

define method production-155
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <PUNCTUATION-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator2 -> <LPAREN-TOKEN> parameter-type-list <RPAREN-TOKEN>
  values(select (prev-state)
           166 => 156;
           154 => 156;
           OTHERWISE => 116;
         end,
         begin
           list(#"function", reverse!(rhs-2));
         end);
end method production-155;

define method production-156
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator2 -> abstract-declarator2 <LPAREN-TOKEN> <RPAREN-TOKEN>
  values(select (prev-state)
           166 => 156;
           154 => 156;
           OTHERWISE => 116;
         end,
         begin
           pair(#"function", pair(list(make(<varargs-declaration>,
                                            name: "", type: unknown-type)), rhs-1));
         end);
end method production-156;

define method production-157
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // abstract-declarator2 -> abstract-declarator2 <LPAREN-TOKEN> parameter-type-list <RPAREN-TOKEN>
  values(select (prev-state)
           166 => 156;
           154 => 156;
           OTHERWISE => 116;
         end,
         begin
           pair(#"function", pair(reverse!(rhs-3), rhs-1));
         end);
end method production-157;

define method production-158
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <SIMPLE-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // external-definition -> <BEGIN-INCLUDE-TOKEN>
  values(select (prev-state)
           247 => 248;
           OTHERWISE => 246;
         end,
         begin
           push-include-level(srcloc-0, rhs-1.string-value);
         end);
end method production-158;

define method production-159
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <EI-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // external-definition -> <END-INCLUDE-TOKEN>
  values(select (prev-state)
           247 => 248;
           OTHERWISE => 246;
         end,
         begin
           do(curry(add-cpp-declaration, srcloc-0), rhs-1.value);
           pop-include-level(srcloc-0);
         end);
end method production-159;

define method production-160
    (prev-state :: <integer>, srcloc-0 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // internal-include-boundary -> epsilon
  values(select (prev-state)
           180 => 181;
           177 => 178;
           OTHERWISE => 22;
         end,
         begin
           #f;
         end);
end method production-160;

define method production-161
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <SIMPLE-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // internal-include-boundary -> <BEGIN-INCLUDE-TOKEN>
  values(select (prev-state)
           180 => 181;
           177 => 178;
           OTHERWISE => 22;
         end,
         begin
           #f;
         end);
end method production-161;

define method production-162
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <EI-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // internal-include-boundary -> <END-INCLUDE-TOKEN>
  values(select (prev-state)
           180 => 181;
           177 => 178;
           OTHERWISE => 22;
         end,
         begin
           do(curry(add-cpp-declaration, srcloc-0), rhs-1.value);
         end);
end method production-162;

define method production-163
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // external-definition -> declaration
  values(select (prev-state)
           247 => 248;
           OTHERWISE => 246;
         end,
         begin
           if (rhs-1)
             parse-progress-report(srcloc-0, "Declaration %s.", rhs-1.canonical-name);
           end if;
           rhs-1;
         end);
end method production-163;

define method production-164
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <NAME-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // identifier -> <IDENTIFIER-TOKEN>
  values(#[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 28, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 28, 0, 0, 28, 0, 28, 0, 28, 0, 0, 28, 0, 28, 0, 0, 28, 0, 28, 0, 0, 28, 0, 28, 0, 28, 0, 28, 0, 0, 28, 0, 28, 0, 0, 28, 0, 0, 28, 0, 0, 28, 0, 0, 28, 0, 0, 28, 0, 28, 0, 28, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 124, 0, 0, 0, 28, 0, 0, 0, 141, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 144, 0, 0, 0, 0, 0, 124, 0, 0, 0, 0, 124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 124, 28, 0, 124, 124, 0, 28, 0, 0, 0, 124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 124, 0, 0, 124, 0, 0, 0, 0, 124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 124, 0, 0, 124, 0, 124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 28][prev-state],
         begin
           rhs-1;
         end);
end method production-164;

define constant $number-of-pops
  = #[0, 1, 2, 3, 3, 3, 3, 3, 3, 1, 2, 1, 1, 1, 3, 2, 1, 4, 4, 1, 3, 1, 2, 4, 1, 1, 1, 1, 4, 1, 3, 3, 3, 1, 3, 3, 1, 3, 3, 1, 3, 3, 3, 3, 1, 3, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 5, 1, 1, 1, 3, 1, 0, 2, 2, 1, 4, 6, 5, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 3, 1, 3, 1, 3, 1, 2, 1, 1, 1, 2, 1, 1, 1, 5, 4, 2, 1, 1, 1, 2, 3, 2, 1, 3, 1, 2, 3, 2, 3, 2, 2, 5, 7, 1, 5, 1, 3, 1, 2, 1, 1, 3, 3, 4, 3, 4, 4, 1, 2, 1, 1, 1, 3, 1, 3, 1, 3, 1, 3, 2, 1, 1, 2, 1, 1, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 1, 1, 0, 1, 1, 1, 1];

define constant $production-table :: <simple-object-vector>
  = vector(#f, production-1, production-2, production-3, production-4, production-5, production-6, production-7, production-8, production-9, production-10, production-11, production-12, production-13, production-14, production-15, production-16, production-17, production-18, production-19, production-20, production-21, production-22, production-23, production-24, production-25, production-26, production-27, production-28, production-29, production-30, production-31, production-32, production-33, production-34, production-35, production-36, production-37, production-38, production-39, production-40, production-41, production-42, production-43, production-44, production-45, production-46, production-47, production-48, production-49, production-50, production-51, production-52, production-53, production-54, production-55, production-56, production-57, production-58, production-59, production-60, production-61, production-62, production-63, production-64, production-65, production-66, production-67, production-68, production-69, production-70, production-71, production-72, production-73, production-74, production-75, production-76, production-77, production-78, production-79, production-80, production-81, production-82, production-83, production-84, production-85, production-86, production-87, production-88, production-89, production-90, production-91, production-92, production-93, production-94, production-95, production-96, production-97, production-98, production-99, production-100, production-101, production-102, production-103, production-104, production-105, production-106, production-107, production-108, production-109, production-110, production-111, production-112, production-113, production-114, production-115, production-116, production-117, production-118, production-119, production-120, production-121, production-122, production-123, production-124, production-125, production-126, production-127, production-128, production-129, production-130, production-131, production-132, production-133, production-134, production-135, production-136, production-137, production-138, production-139, production-140, production-141, production-142, production-143, production-144, production-145, production-146, production-147, production-148, production-149, production-150, production-151, production-152, production-153, production-154, production-155, production-156, production-157, production-158, production-159, production-160, production-161, production-162, production-163, production-164);

define constant $file-start-state = 0;


//----------------------------------------------------------------------
// More parser boilerplate
//----------------------------------------------------------------------

define method aux-get-token
    (parse-state :: <parse-state>) => (result :: <token>);
  get-token(parse-state.tokenizer);
end method aux-get-token;

define method aux-get-token
    (parse-state :: <parse-cpp-state>) => (result :: <token>);
  get-token(parse-state.tokenizer, cpp-line: #t, expand: #f);
end method aux-get-token;

// The initial size of the parser stacks.
// 
define constant $initial-stack-size = 200;

// grow -- internal.
//
// Grow a stack.  Make a new vector twice as long, copy the old elements
// across, and return it.
// 
define method grow (vec :: <simple-object-vector>)
    => new :: <simple-object-vector>;
  let old-size = vec.size;
  let new-size = old-size * 2;
  let new = make(<simple-object-vector>, size: new-size);
  for (index from 0 below old-size)
    new[index] := vec[index];
  end for;
  new;
end method grow;

define constant $eof-token = 0;

define method dformat (template :: <string>, #rest rest)
  apply(format, *standard-error*, template, rest);
end method;

// parse -- internal.
//
// The actual parser loop.  Drive the state machine and maintain the stacks
// until we hit an accept action or until be hit a bogus token.
// 
define method parse-loop
    (parse-state :: <parse-state>, #key debug :: <boolean> = #f)
    => result :: <object>;
  let start-state = $file-start-state;
  let tokenizer = parse-state.tokenizer;

  block (return)
    let state-stack = make(<simple-object-vector>, size: $initial-stack-size);
    let symbol-stack = make(<simple-object-vector>, size: $initial-stack-size);
    let srcloc-stack = make(<simple-object-vector>, size: $initial-stack-size);

    state-stack[0] := start-state;
    let top :: <integer> = 1;
    let (lookahead, lookahead-srcloc) = aux-get-token(parse-state);

    unless (lookahead.token-id == $eof-token)
      let actions :: <simple-object-vector> = $action-table[start-state];
      let action :: <integer> = actions[$eof-token];
    end unless;

    while (#t)
      let state :: <integer> = state-stack[top - 1];

      if (debug)
	dformat("top = %d, state = %d, lookahead = %s\n",
		top, state, lookahead.string-value);
      end if;

      let actions :: <simple-object-vector> = $action-table[state];
      let action :: <integer> = actions[lookahead.token-id];
      let (action-datum, action-kind)
	= truncate/(action, ash(1, $action-bits));
      select (action-kind)
	$error-action =>
	  parse-error(parse-state, "Parse error at or before %s",
                      lookahead.string-value);

	$accept-action =>
	  if (debug)
	    dformat("  accepting.\n");
	  end if;
	  unget-token(tokenizer, lookahead);
	  if (top ~== 2)
	    error("stack didn't get reduced all the way?");
	  end if;
	  return(symbol-stack[1]);

	$shift-action =>
	  if (top == state-stack.size)
	    state-stack := grow(state-stack);
	    symbol-stack := grow(symbol-stack);
	    srcloc-stack := grow(srcloc-stack);
	  end if;
	  if (debug)
	    dformat("  shifting to state %d.\n", action-datum);
	  end if;
	  state-stack[top] := action-datum;
	  symbol-stack[top] := lookahead;
	  srcloc-stack[top] := lookahead-srcloc;
	  top := top + 1;
	  let (new-lookahead, new-srcloc) = aux-get-token(parse-state);
	  lookahead := new-lookahead;
	  lookahead-srcloc := new-srcloc;

	  unless (lookahead.token-id == $eof-token)
	    let actions :: <simple-object-vector>
	      = $action-table[action-datum];
	    let action :: <integer> = actions[$eof-token];
	  end unless;

	$reduce-action =>
	  let semantic-action :: <function>
	    = $production-table[action-datum];
	  let number-pops :: <integer>
	    = $number-of-pops[action-datum];
	  if (debug)
	    dformat("  reducing by production %d, num pops = %d\n",
		    action-datum, number-pops);
	  end if;
	  let old-top = top - number-pops;
	  let extra-args = make(<simple-object-vector>, size: number-pops * 2);
	  for (index from 0 below number-pops)
	    extra-args[index * 2] := symbol-stack[old-top + index];
	    extra-args[index * 2 + 1] := srcloc-stack[old-top + index];
	  end for;
	  let new-srcloc = parse-state;
	  let (new-state :: <integer>, new-symbol)
	    = apply(semantic-action, state-stack[old-top - 1], new-srcloc,
		    extra-args);
	  if (old-top == state-stack.size)
	    state-stack := grow(state-stack);
	    symbol-stack := grow(symbol-stack);
	    srcloc-stack := grow(srcloc-stack);
	  end if;
	  state-stack[old-top] := new-state;
	  symbol-stack[old-top] := new-symbol;
	  srcloc-stack[old-top] := new-srcloc;
	  top := old-top + 1;

      end select;
    end while;
  end block;
end method parse-loop;

//----------------------------------------------------------------------
// External interfaces to the parsing engine.
//----------------------------------------------------------------------

// This function processes an entire include file, leaving a series of
// declarations in the returned parse state.
//
define method parse
    (files :: <sequence> /* of <string> */, #key defines, verbose, structs)
 => (result :: <parse-state>);
  let stream = make(<byte-string-stream>, contents: "",
                    direction: #"input-output");
  for (file in files)
    format(stream, "#include \"%s\"\n", file);
  end for;
  stream.stream-position := #"start";
  let tokenizer = make(<tokenizer>, name: "<top-level>", defines: defines,
                       contents: stream.stream-contents);

  let parse-state = make(<parse-file-state>, tokenizer: tokenizer);
  parse-state.verbose := verbose;

  parse-loop(parse-state);
  if (tokenizer.cpp-decls)
    do(curry(add-cpp-declaration, parse-state), tokenizer.cpp-decls)
  end if;
  parse-state;
end;

// This function parses the contents of the given string and tries to
// interpret it as the name of an object or type declared in "old-state".
// Parse-type will signal an error if no such declaration is found.
//
define method parse-type
    (type :: <string>, old-state :: <parse-file-state>)
 => (result :: <declaration>);
  let tokenizer = make(<tokenizer>, name: concatenate("Type name: ", type),
		       typedefs-from: old-state.tokenizer, contents: type);
  unget-token(tokenizer, make(<alien-name-token>,
			      generator: tokenizer, string: ""));
  let parse-state
    = make(<parse-value-state>, tokenizer: tokenizer, parent: old-state);
  parse-loop(parse-state);
end;

// This function tries to evaluate a preprocessor constant in hopes that
// it will either evaluate to a type or object name or to a constant
// compile time value.  It returns the matched declaration or value, or it
// signals an error. 
//
define method parse-macro
    (name :: <string>, old-state :: <parse-state>)
 => (result :: <object>);
  let old-tokenizer = old-state.tokenizer;
  let tokenizer = make(<tokenizer>, name: concatenate("CPP Macro: ", name),
                       parent: old-tokenizer, contents: "");
  if (check-cpp-expansion(name, tokenizer))
    unget-token(tokenizer, make(<macro-parse-token>,
				generator: tokenizer, string: ""));
    let parse-state
      = make(<parse-macro-state>, tokenizer: tokenizer, parent: old-state);
    parse-loop(parse-state);
  else
    error("Macro not defined in 'parse-macro'.");
  end if;
end;

// This function evaluates a line of CPP input according to a limited set of C
// operators and an odd set of evaluation rules which make undefined
// identifiers into integers.  (Note that this function is used by the
// tokenizer, but also recursively uses the tokenizer by specifying a few
// magic keywords to avoid infinite recursion.)  This function consumes one
// line's worth of tokens from the tokenizer and then leaves it in a
// consistent state for further processing by a different parser.
//
define method cpp-parse (tokenizer :: <tokenizer>) => result :: <integer>;
  block ()
    let parse-state
      = make(<parse-cpp-state>, tokenizer: tokenizer);
    unget-token(tokenizer, make(<cpp-parse-token>,
				generator: tokenizer, string: ""));
    parse-loop(parse-state);
  cleanup 
    get-token(tokenizer); // un-unget the EOF, since we may want to
                          // continue with this tokenizer using a different
                          // lexer
  end block;
end;

